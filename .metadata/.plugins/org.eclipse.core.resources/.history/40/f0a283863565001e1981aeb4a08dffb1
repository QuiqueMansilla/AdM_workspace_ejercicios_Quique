.syntax unified
.thumb
.text

@ Simbolos exportados --> No olvidar de colocar los nombres de las funciones aquí
.global asm_ecovector
.global asm_ecovectorSIMD

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ Prototipo en "C":
@	void asm_ecovector(int16_t *vectorIn, int16_t *vectorOut, uint32_t longitud, uint32_t msegRetardo)
@
@ Parametros recibidos:
@   r0: vector_in
@   r1: vector_out
@   r2: longitud
@   r3: posicion (retardo del eco)
@
@ Valor de retorno
@	void
@

#define SAMPLE_FREC	44100

.thumb_func
	asm_ecovector:
		push {r4-r6} @ r4 auxiliar
						@ Calcular muestra a partir de donde se inicia el eco --> r4
						@ La cuenta es  "posicion" = 882 SAMPLEOffset = msegRetardo*SAMPLE_FREC/1000
		mov r4, #SAMPLE_FREQ  @ r4 será el límite a partir de donde se aplicará el eco
    	mul r4, r4, r3    	  @	r4 = SAMPLE_FREQ*msegRetardo
    	mov r3, #1000  // Se recicla r3 --> 1000 por que son milisegundos, y la frecuencia está en segundos
    	udiv r4, r4, r3  // r4 = r4/1000 (para el ej 10 debería da 882)
    	sub r2, #1  // longitud = longitud - 1
    	mov r6, #-1

	_for9:
    	sub r3, r2, r4  // Se recicla r3 = longitud - muestraEco(882 en el ejemplo)
    	ldrsh r5, [r0, r2, LSL #1]  // Desde la última muestra
    	ldrsh r6, [r0, r3, LSL #1]  // Desde la muestra del eco
    	asr r6, #1	// Muestra de eco dividido por dos
    	add r5, r5, r6 // Se compone la muestra con el eco
    	ssat r6, #16, r5
    	strh r6, [r1, r2, LSL #1] // Se guarda con el índice r2
    	cmp r2, r4  // Si el índice es igual al offset del eco, se debe dejar de añadir
    	sub r2, #1	// Se decrementa el índice, sin modificar el APSR
    	bne _for9

    _for10:
    	// Muestras sin eco
    	ldrh r5, [r0, r2, LSL #1]
    	strh r5, [r1, r2, LSL #1]
    	subs r2, #1
    	bne _for10

		pop {r4-r6}
	    bx lr       @ vuelve adonde fue llamada (especificamente, si "pc"
	                    @ es la direccion, en el codigo del programa, de la
	                    @ instruccion "bl asm_sum" usada para saltar a
	                    @ esta funcion, entonces "lr" contiene ese "pc" + 4).
	                    @ el valor de retorno debe quedar en el registro r0.
	                    @ En este caso, r0 es el resultado de r0 + r1.

        @ Otras alternativas para el retorno
        @ mov pc,lr
        @ bx lr
        @ push {lr} ... pop {pc}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ Prototipo en "C":
@   void asm_ecovectorSIMD(int16_t *vectorIn, int16_t *vectorOut, uint32_t longitud, uint32_t msegRetardo)
@
@ Parametros recibidos:
@   r0: dirección del vector entrada
@   r1: dirección del vector de salida
@   r2: longitud
@   r3: retardo del eco
@
@ Valor de retorno: Nada
@

.thumb_func
    asm_generaEcoSIMD:
    	push {r4-r10}
    	// Calcular muestra a partir de donde se inicia el eco --> r4
    	// La cuenta es SampleOffset = msegRetardo*SAMPLE_FREQ/1000
    	mov r4, #SAMPLE_FREQ  // r4 será el límite a partir de donde se aplicará el eco
    	mul r4, r4, r3    // r4 = SAMPLE_FREQ*msegRetardo
    	mov r3, #1000  // Se recicla r3 --> 1000 por que son milisegundos, y la frecuencia está en segundos
    	udiv r4, r4, r3  // r4 = r4/1000 (para el ej 10 debería da 882)
    	lsr r4, #1 // Como ahora se cargan 2 registros los índices se dividen por 2
    	lsr r2, #1 // Como ahora se cargan 2 registros los índices se dividen por 2
    	sub r2, #1  // longitud = longitud - 1
    	mov r7, #0  // Es un registro dummy, para poder hacer la atenuación por 2 (shift a la derecha) en la muestra con eco

    _for11:
    	// Como ahora se cargan 2 registros los índices se incrementan el doble
    	sub r3, r2, r4  // Se recicla r3 = (longitud - muestraEco)/2 --> (441 en el ejemplo)
    	ldr r5, [r0, r2, LSL #2]  // Desde la última muestra (ahora se cargan 32 bits)
    	ldr r6, [r0, r3, LSL #2]  // Desde la muestra del eco (ahora se cargan 32 bits)
    	shadd16 r6, r6, r7 // muestra de eco dividido por 2 (r7 = 0, por lo que no afecta a r6)
    	qadd16 r6, r6, r5	// r6 = sat(r6 + r5, 16bits)
    	str r6, [r1, r2, LSL #2] // Se guarda con el índice r2
    	cmp r2, r4  // Si el índice es igual al offset del eco, se debe dejar de añadir
    	sub r2, #1	// Se decrementa el índice, sin modificar el APSR
    	bne _for11

    _for12:
    	// Muestras sin eco
    	ldrh r5, [r0, r2, LSL #1]
    	strh r5, [r1, r2, LSL #1]
    	subs r2, #1
    	bne _for12

    	pop {r4-r10}
	        bx lr       @ vuelve adonde fue llamada (especificamente, si "pc"
	                    @ es la direccion, en el codigo del programa, de la
	                    @ instruccion "bl asm_sum" usada para saltar a
	                    @ esta funcion, entonces "lr" contiene ese "pc" + 4).
	                    @ el valor de retorno debe quedar en el registro r0.
	                    @ En este caso, r0 es el resultado de r0 + r1.

        @ Otras alternativas para el retorno
        @ mov pc,lr
        @ bx lr
        @ push {lr} ... pop {pc}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
